/*
1. vsm calculation

input: 
1. A features table, including all the features, 
		such as all the keywords for all the users, 
				all the tags for all the users,
				all the keywords for all the items.
		The schema of this table is (features text[]);
2. A dictionary table, each row represented as an array of features
		The schema of this table is (id int, features text[]);	
3. A relationship table, including the IDs relationship in dictionary table

output:
   The similarity of the IDs in relationship table

*/
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.encode_feature
    (
	input_table			TEXT,
	feature_column		TEXT,
	features_table		TEXT
	)
RETURNS TEXT AS $$
DECLARE
    stmt			TEXT;
BEGIN
	EXECUTE 'DROP TABLE IF EXISTS ' || features_table;

	stmt = MADLIB_SCHEMA.__format
			(
				'CREATE TABLE % AS
				 SELECT row_number() OVER (ORDER BY %) as feat_no,
						% as feature
				 FROM %
				 GROUP BY %
				 DISTRIBUTED BY(feature)',
				ARRAY[
					features_table,
					feature_column,
					feature_column,
					input_table,
					feature_column
				]
				 
			);
	
	EXECUTE stmt;

	RETURN features_table;
END
$$ LANGUAGE PLPGSQL;

-- no weight column, all default as 1
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.gen_dict_table 
    (
	input_table		TEXT,
	id_column		TEXT,
	feature_column	TEXT,
	features_table	TEXT,
	dict_table		TEXT
	)
RETURNS void AS $$
DECLARE
    stmt			TEXT;
	num_features	INT;
BEGIN
	EXECUTE 'DROP TABLE IF EXISTS ' || dict_table;


	EXECUTE 'SELECT count(feat_no) FROM ' || features_table INTO num_features;

	-- based on the encoded table to generate the dictionary table
	-- duplicated rows will be removed from the input table
	stmt = MADLIB_SCHEMA.__format
			(
				'CREATE TABLE %(id, %_weig) AS
				 SELECT id,
						MADLIB_SCHEMA.svec_cast_positions_float8arr
							(array_agg(feat_no), array_agg(weight)::FLOAT8[], %, 0.0)
				 FROM 
					(
					SELECT t1.% as id, feat_no, 1 as weight
					FROM % t1, % t2
					WHERE t1.% = t2.feature
					GROUP BY %, feat_no
					) t
				 GROUP BY id
				 DISTRIBUTED BY(id)',
				ARRAY[
					dict_table,
					feature_column,
					num_features::TEXT,
					id_column,
					input_table,
					features_table,
					feature_column,
					id_column
				]
			);
	EXECUTE stmt;

	RETURN;
END
$$ LANGUAGE PLPGSQL;


-- generate the dictionary table with weights(will sum the weight if they have multiple items)
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.gen_dict_table 
    (
	input_table		TEXT,
	id_column		TEXT,
	feature_column	TEXT,
   	weig_column		TEXT,
	features_table	TEXT,
	dict_table		TEXT
	)
RETURNS void AS $$
DECLARE
    stmt			TEXT;
	num_features	INT;
BEGIN
	EXECUTE 'DROP TABLE IF EXISTS ' || dict_table;


	EXECUTE 'SELECT count(feat_no) FROM ' || features_table INTO num_features;

	-- based on the encoded table to generate the dictionary table
	stmt = MADLIB_SCHEMA.__format
			(
				'CREATE TABLE %(id, %_weig) AS
				 SELECT id,
						MADLIB_SCHEMA.svec_cast_positions_float8arr
							(array_agg(feat_no), array_agg(weight)::FLOAT8[], %, 0.0)
				 FROM 
					(
					SELECT t1.% as id, feat_no, sum(%) as weight
					FROM % t1, % t2
					WHERE t1.% = t2.feature
					GROUP BY %, feat_no
					) t
				 GROUP BY id
				 DISTRIBUTED BY(id)',
				ARRAY[
					dict_table,
					feature_column,
					num_features::TEXT,
					id_column,
					weig_column,
					input_table,
					features_table,
					feature_column,
					id_column
				]
			);
	EXECUTE stmt;

	RETURN;
END
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.cal_vsm_self 
    (
	input_table			TEXT,
	id_column			TEXT,
	feature_column		TEXT,
	features_table		TEXT,
	id_features_table	TEXT,
	vsm_table			TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt				TEXT;
	dict_table			TEXT := input_table || '_dict';
	num_ids				INT;
BEGIN

	PERFORM MADLIB_SCHEMA.gen_dict_table 
		(
			input_table,
			id_column,
			feature_column,
			features_table,
			dict_table			
		);

	EXECUTE 'SELECT count(feat_no) FROM ' || id_features_table INTO num_ids;

	EXECUTE 'DROP TABLE IF EXISTS ' || vsm_table;

	-- generate the vsm
	stmt = MADLIB_SCHEMA.__format
			(
				'CREATE TEMP TABLE % AS
				 SELECT t1.id as %,
						MADLIB_SCHEMA.svec_cast_positions_float8arr
							(
							array_agg(feat_no), 
							array_agg
								(
								MADLIB_SCHEMA.svec_dot(t1.%_weig, t2.%_weig)
									/
								(
								sqrt(MADLIB_SCHEMA.svec_dot(t1.%_weig, t1.%_weig)) *
								sqrt(MADLIB_SCHEMA.svec_dot(t2.%_weig, t2.%_weig))
								) 
								)::FLOAT8[],
							%, 
							0.0
							) as %_sim
				 FROM 
					% t1, 
					(
					SELECT feat_no, %_weig
					FROM % n1, % n2
					WHERE n1.feature = n2.id
					)t2
				 GROUP BY %
				 DISTRIBUTED BY(%)',
				ARRAY[
					vsm_table,
					id_column,
					feature_column,
					feature_column,
					feature_column,
					feature_column,
					feature_column,
					feature_column,
					num_ids::TEXT,
					feature_column,
					dict_table,
					feature_column,
					id_features_table,
					dict_table,
					id_column,
					id_column
				]
			);

	RAISE INFO 'self vsm:%', stmt;

	EXECUTE stmt;

	return vsm_table;
END
$$ LANGUAGE PLPGSQL;


/*
 * Generate the vsm table based on the dictionary table 
 * which was already done preprocessing.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.cal_vsm
    (
	dict_table			TEXT,
	feature_column		TEXT,
	relation_table		TEXT,
	rel_oid_column		TEXT,
	rel_did_column		TEXT,
	vsm_table			TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt		TEXT;
BEGIN
	EXECUTE 'DROP TABLE IF EXISTS ' || vsm_table;

	-- generate the vsm
	stmt = MADLIB_SCHEMA.__format
			(
				'CREATE TEMP TABLE % AS
				 SELECT t3.%, 
						t3.%,
						coalesce(
							MADLIB_SCHEMA.svec_dot(t1.%_weig, t2.%_weig)
								/
							(sqrt(MADLIB_SCHEMA.svec_dot(t1.%_weig, t1.%_weig)) *
							sqrt(MADLIB_SCHEMA.svec_dot(t2.%_weig, t2.%_weig))
							),
							0.0
						)
						as %_sim
				 FROM % t1, % t2, % t3
				 WHERE t1.id = t3.% and t2.id = t3.%
				 DISTRIBUTED BY(%, %)',
				ARRAY[
					vsm_table,
					rel_oid_column,
					rel_did_column,
					feature_column,
					feature_column,
					feature_column,
					feature_column,
					feature_column,
					feature_column,
					feature_column,
					dict_table,
					dict_table,
					relation_table,
					rel_oid_column,
					rel_did_column,
					rel_oid_column,
					rel_did_column
				]
			);
		EXECUTE stmt;
	return vsm_table;
END
$$ LANGUAGE PLPGSQL;


/*
 * Generate the vsm table based on the dictionary table 
 * which was already done preprocessing.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.cal_vsm
    (
	lf_dict_table			TEXT,
	lf_feature_column		TEXT,
	rh_dict_table			TEXT,
	rh_feature_column		TEXT,
	relation_table			TEXT,
	rel_oid_column			TEXT,
	rel_did_column			TEXT,
	vsm_table				TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt		TEXT;
BEGIN
	EXECUTE 'DROP TABLE IF EXISTS ' || vsm_table;

	-- generate the vsm
	stmt = MADLIB_SCHEMA.__format
			(
				'CREATE TEMP TABLE % AS
				 SELECT t3.%, 
						t3.%,
						coalesce(
							MADLIB_SCHEMA.svec_dot(t1.%_weig, t2.%_weig)
								/
							(sqrt(MADLIB_SCHEMA.svec_dot(t1.%_weig, t1.%_weig)) *
							sqrt(MADLIB_SCHEMA.svec_dot(t2.%_weig, t2.%_weig))
							),
							0.0
						)
						as %_sim
				 FROM % t1, % t2, % t3
				 WHERE t1.id = t3.% and t2.id = t3.%
				 DISTRIBUTED BY(%, %)',
				ARRAY[
					vsm_table,
					rel_oid_column,
					rel_did_column,
					lf_feature_column,
					rh_feature_column,
					lf_feature_column,
					lf_feature_column,
					rh_feature_column,
					rh_feature_column,
					lf_feature_column,
					lf_dict_table,
					rh_dict_table,
					relation_table,
					rel_oid_column,
					rel_did_column,
					rel_oid_column,
					rel_did_column
				]
			);
		EXECUTE stmt;
	return vsm_table;
END
$$ LANGUAGE PLPGSQL;



/*
	Retrieve the vsm table based on the raw data
	which need to be preprocessed.
	@note relation_table must be distributed by the rel_oid_column
		  and build index on the rel_did_column
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.cal_vsm 
    (
	input_table			TEXT,
	id_column			TEXT,
	feature_column		TEXT,
	weig_column			TEXT,
	relation_table		TEXT,
	rel_oid_column		TEXT,
	rel_did_column		TEXT,
	features_table		TEXT,
	vsm_table			TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt				TEXT;
	dict_table			TEXT := input_table || '_dict';
BEGIN

	PERFORM MADLIB_SCHEMA.gen_dict_table 
		(
			input_table,
			id_column,
			feature_column,
			weig_column,
			features_table,
			dict_table			
		);

	EXECUTE 'DROP TABLE IF EXISTS ' || vsm_table;

	RETURN MADLIB_SCHEMA.cal_vsm
			(
				dict_table,
				feature_column,
				relation_table,
				rel_oid_column,
				rel_did_column,
				vsm_table
			);
END
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.cal_vsm 
    (
	left_table			TEXT,
	lf_id_column		TEXT,
	lf_feature_column	TEXT,
	lf_weig_column		TEXT,
	right_table			TEXT,
	rh_id_column		TEXT,
	rh_feature_column	TEXT,
	rh_weig_column		TEXT,	
	relation_table		TEXT,
	rel_oid_column		TEXT,
	rel_did_column		TEXT,
	features_table		TEXT,
	vsm_table			TEXT
    )
RETURNS TEXT AS $$
DECLARE
    stmt				TEXT;
	lf_dict_table		TEXT := input_table || '_lf_dict';
	rh_dict_table		TEXT := input_table || '_rh_dict';	
BEGIN

	PERFORM MADLIB_SCHEMA.gen_dict_table 
		(
			left_table,
			lf_id_column,
			lf_feature_column,
			lf_weig_column,
			features_table,
			lf_dict_table			
		);

	PERFORM MADLIB_SCHEMA.gen_dict_table 
		(
			right_table,
			rh_id_column,
			rh_feature_column,
			rh_weig_column,
			features_table,
			rh_dict_table			
		);


	EXECUTE 'DROP TABLE IF EXISTS ' || vsm_table;

	RETURN MADLIB_SCHEMA.cal_vsm
			(
				lf_dict_table,
				lf_feature_column,
				rh_dict_table,
				rh_feature_column,
				relation_table,
				rel_oid_column,
				rel_did_column,
				vsm_table
			);
END
$$ LANGUAGE PLPGSQL;


