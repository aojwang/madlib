# coding=utf-8

"""
@file assoc_rules.py_in

@brief Association Rules - Apriori Algorithm Implementation.

@namespace assoc_rules
"""

import time
import plpy

"""
@brief if the given condition is false, then raise an error with the message
@param condition    the condition to be assert
@param msg          the error message to be reported
"""
def __assert(condition, msg):
    if not condition :
        plpy.error(msg);

"""
@brief test if the 1st value is greater than the 2nd value
@param val1    a float number
@param val2    a float number
@return true if the 1st value greater than the 2nd value.
        Otherwise return false
"""
def __float_gt(val1, val2):
    return val1 - val2 > 1E-14;


"""
@brief test if the 1st value is less than or equal to the 2nd value
@param val1    a float number
@param val2    a float number
@return true if the 1st value is less than or equal to the 2nd value.
        Otherwise return false
"""
def __float_le(val1, val2):
    return (val1 - val2) < -1E-14 or abs(val1 - val2) < 1E-14;


"""
@brief The entry function for the Apriori.
@param support         minimum level of support needed for each itemset
                       to be included in result
@param confidence      minimum level of confidence needed for each rule
                       to be included in result
@param tid_col         name of the column storing the transaction ids
@param item_col        name of the column storing the products
@param input_table     name of the table where the data is stored
@param output_schema   name of the schema where the final results will be stored
@param verbose         determining if output contains comments
"""
def assoc_rules(madlib_schema, support, confidence, tid_col,
                item_col, input_table, output_schema, verbose):

    begin_func_exec = time.time();
    begin_step_exec = time.time();
    cal_itemsets_time = 0;
    plpy.execute("""
        SELECT set_config('search_path', 
                current_setting('search_path') || ',{madlib_schema}', 
                false)""".format(madlib_schema=madlib_schema));
    #check parameters
    __assert(
            support is not None and
            confidence is not None and
            tid_col is not None and
            item_col is not None and
            input_table is not None and
            verbose is not None,
            "none of the parameters except the output_schema should be null"
            );

    __assert(
            __float_gt(support, 0) and __float_le(support, 1),
            "the parameter support must be in range of (0, 1]"
            );

    __assert(
            __float_gt(confidence, 0) and __float_le(confidence, 1),
            "the parameter confidence must be in range of (0, 1]"
            );

    # once the utility module is ready, it's better to use
    # the table_exists and column_exists to do the assertion
    try:
        rv = plpy.execute("""
            SELECT count(*) as cnt
            FROM pg_attribute
            where attrelid='{0}'::regclass AND
                  attname IN (lower(btrim('{1}', ' ')), lower(btrim('{2}', ' ')))
            """.format(input_table, tid_col, item_col)
            );
        __assert(rv[0]["cnt"] == 2, "the tid_col and item_col  in " +
                 "the input table");
    except:
        plpy.error("the input table must exist and the tid_col and " +
                   "item_col must be in the input table");

    if output_schema is None :
        rv = plpy.execute("SELECT current_schema() as s");
        output_schema = rv[0]["s"];
    else :
        rv = plpy.execute("""
            SELECT count(*) as cnt
            FROM pg_namespace
            where nspname = '{0}'
            """.format(output_schema)
            );
        __assert(rv[0]["cnt"] == 1, "the output schema does not exist");


    if verbose:
        plpy.info("finished checking parameters");

    # create the result table for keeping the generated rules
    plpy.execute("DROP TABLE IF EXISTS {0}.assoc_rules".format(output_schema));
    plpy.execute("""
        CREATE TABLE {0}.assoc_rules
            (
            ruleId      INT,
            pre         TEXT[],
            post        TEXT[],
            support     FLOAT8,
            confidence  FLOAT8,
            lift        FLOAT8,
            conviction  FLOAT8
            )
        m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (ruleId)')""".format(output_schema)
        );

    # the auxiliary table for keeping the association rules
    plpy.execute("DROP TABLE IF EXISTS assoc_rules_aux_tmp");
    plpy.execute("""
        CREATE TEMP TABLE assoc_rules_aux_tmp
            (
            ruleId      SERIAL,
            pre         TEXT,
            post        TEXT,
            support     FLOAT8,
            confidence  FLOAT8,
            lift        FLOAT8,
            conviction  FLOAT8
            )
        m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (ruleId)')""");

    # if the tid in the input table doesn't start with 1 and the IDs are not
    # continuous, then we will make the IDs start with 1 and continuous.
    # note: duplicated records will be removed.
    rv = plpy.execute("""
        SELECT min({tid_col}) as i, count(DISTINCT {tid_col}) as c1
        FROM {input_table}
        """.format(tid_col=tid_col, input_table=input_table));
    
    min_tid = int(rv[0]["i"]);
    num_tranx = rv[0]["c1"];
    min_supp_tranx = float(num_tranx) * support;

    # get the items whose counts are greater than the given
    # support counts. Each item will be given a continuous number.
    begin_step_exec = time.time();
    plpy.execute("DROP TABLE IF EXISTS assoc_item_uniq");
    plpy.execute("""
        CREATE TEMP TABLE assoc_item_uniq
            (item_id BIGSERIAL, item_text TEXT, cnt BIGINT)
        m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (item_id)')
        """);
    plpy.execute("""
        INSERT INTO assoc_item_uniq (item_text, cnt) 
        SELECT item, count(tid) as cnt
        FROM (
            SELECT {item_col} as item, {tid_col} as tid FROM {input_table}
            WHERE {item_col} IS NOT NULL AND {tid_col} IS NOT NULL
            GROUP BY {item_col}, {tid_col}
            ) t
        GROUP BY item
        HAVING count(tid)::FLOAT8 >= {min_supp}
        """.format(min_supp=min_supp_tranx, item_col=item_col, 
                   tid_col=tid_col, input_table=input_table));
    if verbose :
        plpy.info("finished encoding items: time {0}".format(
            time.time() - begin_step_exec));
    rv = plpy.execute("SELECT count(item_id) as c FROM assoc_item_uniq");
    num_supp_prod = rv[0]["c"];
        
    if min_tid < 1 :
        min_tid = 1 - min_tid;
    else :
        min_tid = 0;

    plpy.info("Beginning iteration #1");
    begin_step_exec = time.time();

    # this table keeps the patterns in each iteration.
    plpy.execute("DROP TABLE IF EXISTS assoc_rule_sets");
    plpy.execute("""
        CREATE TEMP TABLE assoc_rule_sets
            (
            text_svec   TEXT,
            support     FLOAT8,
            iteration   INT
            )
        m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (text_svec)')
        """.format(madlib_schema = madlib_schema));

    # this table keeps the patterns in the current iteration.
    plpy.execute("DROP TABLE IF EXISTS assoc_rule_sets_loop");
    plpy.execute("""
        CREATE TEMP TABLE assoc_rule_sets_loop
            (
            id          BIGINT,
            set_list    {madlib_schema}.bitmap,
            support     FLOAT8,
            tids        {madlib_schema}.bitmap
            )
        m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (id)')
        """.format(madlib_schema = madlib_schema));
        
    plpy.execute("""
         INSERT INTO assoc_rule_sets_loop (id, set_list, support, tids)
         SELECT t2.item_id,
                {madlib_schema}.bitmap_agg(t2.item_id, 4),
                t2.cnt::FLOAT8 / {num_tranx},
                {madlib_schema}.bitmap_agg(t1.{tid_col} + {min_tid}, 256)
         FROM {input_table} t1 RIGHT JOIN assoc_item_uniq t2
         ON t1.{item_col} = t2.item_text AND t1.{tid_col} IS NOT NULL
         GROUP BY t2.item_id, t2.cnt
         """.format(madlib_schema = madlib_schema, item_col=item_col, 
                tid_col=tid_col, input_table=input_table,
                min_tid=min_tid, num_tranx = num_tranx));

    rv = plpy.execute("""
        SELECT count(id) as c1, max(id) as c2
        FROM assoc_rule_sets_loop
        """);
    num_item_loop = rv[0]["c1"];
    max_item_loop = rv[0]["c2"];

    __assert(
            (num_item_loop == max_item_loop) or
            (num_item_loop == 0 and max_item_loop is None),
            "internal error: num_item_loop must be equal to max_item_loop"
        );
    if verbose :
        plpy.info("finished generating first frequent itemsets: time {0}".format(
            time.time() - begin_step_exec));
            
    # to avoid the self cross join of the table assoc_rule_sets_loop,
    # we use the following table to generate the join relationship
    # so that we can use inner join (hash join)
    plpy.execute("DROP TABLE IF EXISTS rule_set_rel");
    plpy.execute("""
         CREATE TEMP TABLE rule_set_rel
            (
            sid     BIGINT,
            did     BIGINT
            )
         m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (sid)')
         """);

    # As two different svecs may have the same hash key,
    # we use this table to assign a unique ID for each svec.
    plpy.execute("DROP TABLE IF EXISTS assoc_loop_aux");
    plpy.execute("""
         CREATE TEMP TABLE assoc_loop_aux
            (
            id              BIGSERIAL,
            set_list        {madlib_schema}.bitmap,
            support         FLOAT8,
            tids            {madlib_schema}.bitmap
            )
         m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (id)')
         """.format(madlib_schema = madlib_schema));

    if verbose  :
        plpy.info("{0} Frequent itemsets found in this iteration".format(
            num_supp_prod));
        plpy.info("Completed iteration # 1. Time: {0}".format(
            time.time() - begin_step_exec));

    iter = 0;

    while num_item_loop > 0 :
        begin_step_exec = time.time();
        iter = iter + 1;

        if verbose  :
            plpy.info("Beginning iteration # {0}".format(iter + 1));

        plpy.execute("TRUNCATE TABLE rule_set_rel");
        plpy.execute("""
             INSERT INTO rule_set_rel(sid, did)
             SELECT t1.id, generate_series(t1.id + 1, {0})
             FROM assoc_rule_sets_loop t1
             """.format(num_item_loop));

        plpy.execute("""
             INSERT INTO assoc_rule_sets
                (text_svec, support, iteration)
             SELECT array_to_string(
                    {madlib_schema}.bitmap_nonzero_positions(set_list), ','),
                    support, {iter}
             FROM assoc_rule_sets_loop""".format(madlib_schema = madlib_schema, iter = iter)
             );

        if verbose  :
            plpy.info("time of preparing data: {0}".format(
                 time.time() - begin_step_exec));

        # generate the patterns for the next iteration
        plpy.execute("ALTER SEQUENCE assoc_loop_aux_id_seq RESTART WITH 1");
        plpy.execute("TRUNCATE TABLE assoc_loop_aux");
        plpy.execute("""
           INSERT INTO assoc_loop_aux(set_list, support, tids)
           SELECT DISTINCT ON(set_list::INT[]) set_list,
                   {madlib_schema}.bitmap_nonzero_count(tids)::FLOAT8 / {num_tranx},
                   tids
           FROM (
             SELECT
                 t1.set_list | t3.set_list
                 as set_list,
               t1.tids & t3.tids as tids
             FROM assoc_rule_sets_loop t1,
                  rule_set_rel t2,
                  assoc_rule_sets_loop t3
             WHERE t1.id = t2.sid and t2.did = t3.id
           ) t
           WHERE {madlib_schema}.bitmap_nonzero_count(set_list)::INT = {next_iter} AND
                 {madlib_schema}.bitmap_nonzero_count(tids)::FLOAT8 >= {min_supp_tranx}
           """.format(madlib_schema = madlib_schema, num_tranx = num_tranx,
                      next_iter = iter + 1, min_supp_tranx = min_supp_tranx)
           );
        
        
        
        #if 3 == iter : return (None, None, None, None);
        plpy.execute("TRUNCATE TABLE assoc_rule_sets_loop");
        plpy.execute("""
            INSERT INTO assoc_rule_sets_loop(id, set_list, support, tids)
            SELECT * FROM assoc_loop_aux
            """
            );

        rv = plpy.execute("""
            SELECT count(id) as c1, max(id) as c2
            FROM assoc_rule_sets_loop
            """);
        num_item_loop = rv[0]["c1"];
        max_item_loop = rv[0]["c2"];
        __assert(
            (num_item_loop == max_item_loop) or
            (num_item_loop == 0 and max_item_loop is None),
            "internal error: num_item_loop must be equal to max_item_loop"
            );

        if verbose :
            plpy.info("{0} Frequent itemsets found in this iteration".format(
                num_item_loop));
            plpy.info("Completed iteration # {0}. Time: {1}".format(
                    iter + 1, time.time() - begin_step_exec));

        cal_itemsets_time = cal_itemsets_time + (time.time() - begin_step_exec);
        

    if (num_item_loop == 0) and (iter < 2) and verbose :
        plpy.info("No association rules found that meet given criteria");
        plpy.info("finished itemsets finding. Time: {0}".format(
            cal_itemsets_time));
        total_rules = 0;
    else :
        if (verbose) :
            plpy.info("begin to generate the final rules");

        begin_step_exec = time.time();
        # generate all the final rules
        plpy.execute("""
             INSERT INTO assoc_rules_aux_tmp
                (pre, post, support, confidence, lift, conviction)
             SELECT
                t.item[1],
                t.item[2],
                t.support_xy,
                t.support_xy / x.support,
                t.support_xy / (x.support * y.support),
                CASE WHEN abs(t.support_xy / x.support - 1) < 1.0E-10 THEN
                    0
                ELSE
                    (1 - y.support) / (1 - (t.support_xy / x.support))
                END
            FROM (
                SELECT
                    {0}.gen_rules_from_cfp(text_svec, iteration) as item,
                    support as support_xy
                FROM assoc_rule_sets
                WHERE iteration > 1
            ) t, assoc_rule_sets x, assoc_rule_sets y
            WHERE t.item[1] = x.text_svec AND
                  t.item[2] = y.text_svec AND
                  (t.support_xy / x.support) >= {1}
            """.format(madlib_schema, confidence)
            );

        if verbose :
            rv = plpy.execute("""
                SELECT count(*) as c FROM assoc_rules_aux_tmp
                """);
            num_item_loop = rv[0]["c"];
            plpy.info("{0} Total association rules found. Time: {1}".format(
                    num_item_loop, time.time() - begin_step_exec));

        # generate the readable rules
        plpy.execute("DROP TABLE IF EXISTS pre_tmp_table");
        plpy.execute("""
             CREATE TEMP TABLE pre_tmp_table AS
             SELECT ruleId, array_agg(item_text) as pre
             FROM
                (
                    SELECT
                        ruleId,
                        unnest(string_to_array(pre, ','))::BIGINT as pre_id
                    FROM assoc_rules_aux_tmp
                ) s1, assoc_item_uniq s2
             WHERE s1.pre_id = s2.item_id
             GROUP BY ruleId
             m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (ruleId)')
             """);

        plpy.execute("DROP TABLE IF EXISTS post_tmp_table");
        plpy.execute("""
             CREATE TEMP TABLE post_tmp_table AS
             SELECT ruleId, array_agg(item_text) as post
             FROM
                (
                    SELECT
                        ruleId,
                        unnest(string_to_array(post, ','))::BIGINT as post_id
                    FROM assoc_rules_aux_tmp
                ) s1, assoc_item_uniq s2
             WHERE s1.post_id = s2.item_id
             GROUP BY ruleId
             m4_ifdef(`__GREENPLUM__',`DISTRIBUTED BY (ruleId)')
             """);

        plpy.execute("""
             INSERT INTO {0}.assoc_rules
             SELECT t1.ruleId, t2.pre, t3.post, support,
                    confidence, lift, conviction
             FROM
                assoc_rules_aux_tmp t1,
                pre_tmp_table t2,
                post_tmp_table t3
             WHERE t1.ruleId = t2.ruleId AND t1.ruleId = t3.ruleId
             """.format(output_schema)
             );

        # if in verbose mode, we will keep all the intermediate tables
        if not verbose :
            plpy.execute("""
                DROP TABLE IF EXISTS post_tmp_table;
                DROP TABLE IF EXISTS pre_tmp_table;
                DROP TABLE IF EXISTS assoc_rules_aux_tmp;
                DROP TABLE IF EXISTS assoc_item_uniq;
                DROP TABLE IF EXISTS assoc_rule_sets;
                DROP TABLE IF EXISTS assoc_rule_sets_loop;
                DROP TABLE IF EXISTS rule_set_rel;
                DROP TABLE IF EXISTS assoc_loop_aux;
                """);

        if verbose :
            rv = plpy.execute("""
                SELECT count(*) as c FROM {0}.assoc_rules
                """.format(output_schema));
            num_item_loop = rv[0]["c"];
            plpy.info("{0} Total association rules found. Time: {1}".format(
                    num_item_loop, time.time() - begin_step_exec));

        rv = plpy.execute("""
            SELECT count(*) as c FROM {0}.assoc_rules
            """.format(output_schema));
        total_rules = rv[0]["c"];

    return (
            output_schema,
            'assoc_rules',
            total_rules,
            time.time() - begin_func_exec
           );

