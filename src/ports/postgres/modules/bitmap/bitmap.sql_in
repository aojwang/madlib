/* ----------------------------------------------------------------------- *//** 
 *
 * @file bitmap.sql_in
 *
 * @brief SQL type definitions and functions for bitmap data type
 *        <tt>bitmap</tt>
 *
 * @sa For an introduction to the bitmap implementation, see the module
 *     description \ref grp_bitmap.
 *
 *//* ----------------------------------------------------------------------- */


/**
@addtogroup grp_bitmap

@about

Many data mining algorithms need to deal with a set of integers. For example 
Apriori takes as input the IDs of the transactions that contain a specific item. 
Using an array to keep these IDs leads to large storage overhead and low efficiency 
in processing. We will need a more compact and efficient representation of these 
numbers. MADLIB_SCHEMA.bitmap is a UDT that serves this purpose. 

For example, a set of integers (say I), which can be ordered or out of ordered, 
like this one: 

\code
1,2,3, 10000000, 32~3100000.
\endcode

If we use an array to keep them, it would occupy more than 24MB of memory/disk 
space. Using a traditional bitmap where each bit represents one number, we would 
still need more than 9MB space for those integers.

MADLIB_SCHEMA.bitmap uses an INT4 array to keep the bitmap image. We denote the
bitmap image as B(n+1,w_1,w_2,...w_n), where n+1 is the total number of elements 
in the bitmap and w_i (1<=i<=n) is called as a word with 32-bit. There are two 
types of words: 
> Normal Word (NW)
  The highest bit of which is 0. The rest 31 bits are used to represent numbers.
  The absolute positions of the nonzero bits of a NW in the bitmap image are the 
  numbers represented by the NW. 

> Composite Word (CW)
  The highest bit of which is 1. A composite word can be breakup to multiple
  normal words. The breakup rules are as follows: 
    + The second highest bit is 1 means that the composite word (w) represents 
      (w & 0x4FFFFFFF) number of normal words with value 0x7FFFFFFF.
    + The second highest bit is 0 means that the composite word (w) represents
      (w & 0x4FFFFFFF) number of normal words with value 0x00000000.

Therefore, given the bitmap image B(n+1,w_1,w_2,...,w_n), we can know that the 
start position (p_i) of w_i is:
\code
     p_i = 1;                                              (i=1)
     p_i = sum(w_j > 0 ? 32 : (w_j & 0x4FFFFFFF) * 31;     (j=1..i-1 and i=2..n)
\endcode  

With the start position of each word, it's simple to calculate the absolute
positions of the nonzero bits in each word. That's, it's easy to restore a 
bitmap to the input integers represented by itself. 

For example, the aforementioned integer set I would be encoded as the 
following array, denoted as E, with only five words, which occupy only 
5 * 4 = 20 bytes: 
\code
array[0x5, 0x7, 0xC001869F, 0x80036574, 0x80000]
\endcode

E[0], i.e. 0x5, is always set to the total 
number of normal and composite words, i.e. 4 plus one. 

E[1], i.e. 0x7, is a normal word. The start position is 1. As the lowest 3 bits 
are all ones, we know that I has 1,2,3 in it. 

E[2], i.e. 0xC001869F, is a composite word. The start position is 32.
It can be breakup to 0x00001869F number of normal words with value 0x7FFFFFFF. 
That means the integers from 32 to 3100000(31 + 0x1869F * 31) are in I

E[3], i.e. 0x80036574, is a composite word. The start positions is 3100001.
It can be breakup to 0x00036574 number of normal words with value 0x00000000.
That means no integers are represented by this word.

E[4], i.e. 0x80000, is a normal word. The start positions is 9999980.
As the 20th bit is 1, we know that I has 10000000 (9999980 + 20) in it.
    
    
@usage

    A bitmap can be constructed as follows:
    <pre>
    SELECT 'x1,x2,x3,...,xk'::MADLIB_SCHEMA.bitmap;
    </pre>
    where x1,x2,x3,...,xk are integers.
    
    Or, it can also be built from an integer array:
    <pre>
    SELECT ('{x1,x2,x3,...xk}'::INT[])::MADLIB_SCHEMA.bitmap;
    </pre>
    
    Or, it can be aggregated from a column with integer type of a table:
    <pre>
    SELECT MADLIB_SCHEMA.bitmap_agg(tid) FROM trans_table;
    </pre>
    where tid is the column with integer type.
    
    Syntax reference can be found in bitmap.sql_in.

    Users need to add MADLIB_SCHEMA to their search_path to use the bitmap 
    operators defined in the module.

@examp

Here, we will give examples for the functions that we provided in this version.

The following three examples show how to build a bitmap:

Building the bitmap from a cstring:
\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap AS bitmap
 bitmap  
---------
 1~3
\endcode

Building the bitmap from an integer array. NULLs are not allowed. The duplicated 
numbers in the array will be ignored.
\code
sql> SELECT array[1,2,3]::MADLIB_SCHEMA.bitmap AS bitmap
 bitmap  
---------
 1~3
\endcode

Building the bitmap by aggregating integers from a column of a table. NULLs are 
not allowed. The duplicated numbers in the column will be ignored.
\code
sql> CREATE TEMP TABLE t1(id) AS SELECT generate_series(32, 62) UNION ALL
                                 SELECT unnest(array[1,2,3,4];
sql> SELECT MADLIB_SCHEMA.bitmap_agg(id) AS bitmap FROM t1;
 bitmap  
---------
 1~4,32~62
\endcode

The following two examples show how we use the bitwise operations: | and &.
\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap | '4,3,2'::MADLIB_SCHEMA.bitmap AS bitmap_or
 bitmap_or  
---------
 1~4
\endcode

\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap & '4,3,2'::MADLIB_SCHEMA.bitmap AS bitmap_and
 bitmap_and  
---------
 2,3
\endcode


The following two examples show the CASTs for the bitmap:
\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap::INT[] AS intcast
 intcast
---------
 {2,7}
\endcode

\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap::varbit AS varbitcast
            varbitcast             
-----------------------------------
 111000000000000000000000000000001
\endcode


@sa File bitmap.sql_in documenting the SQL functions.

*/


m4_include(`SQLCommon.m4')

CREATE TYPE MADLIB_SCHEMA.bitmap;

/*
 * @brief the 'in' function for the bitmap data type
 *
 * @param args[0]   the input string, which must be split by a comma.
 *
 * @return the bitmap representing the input string
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_in(cstring)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;


/*
 * @brief the 'out' function for the bitmap data type.
 *
 * @param args[0]   the bitmap
 *
 * @return the string representing the bitmap.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_out(MADLIB_SCHEMA.bitmap)
RETURNS cstring
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;


CREATE TYPE MADLIB_SCHEMA.bitmap (
   internallength = VARIABLE, 
   input = MADLIB_SCHEMA.bitmap_in,
   output = MADLIB_SCHEMA.bitmap_out,
   storage = EXTENDED,
   alignment = int4
);


/*
 * @brief the step function for aggregating the input numbers to
 *        a compressed bitmap.
 *
 * @param args[0]   the array indicating the state
 * @param args[1]   the input number
 * @param args[2]   the number of empty elements will be dynamically
 *                  added to the state array. The default values is 16.
 *
 * @return an array indicating the state after inserting the input number.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_agg_sfunc
(
    MADLIB_SCHEMA.bitmap,
    INT8,
    INT4
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE;


/*
 * @brief the step function for aggregating the input numbers to
 * a compressed bitmap.
 *
 * @param args[0]   The array indicating the state
 * @param args[1]   the input number
 *
 * @return an array indicating the state after inserting the input number.
 * @note the default value for the second parameter is 16
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_agg_sfunc
(
    MADLIB_SCHEMA.bitmap,
    INT8
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE;


/*
 * @brief the pre-function for the bitmap aggregation.
 *
 * @param args[0]   the first state
 * @param args[1]   the second state
 *
 * @return an array of merging the first state and the second state.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_agg_pfunc
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE;


CREATE AGGREGATE MADLIB_SCHEMA.bitmap_agg
(
    INT8,
    INT4
)
(
    SFUNC=MADLIB_SCHEMA.bitmap_agg_sfunc,
    STYPE=MADLIB_SCHEMA.bitmap
    m4_ifdef(`__GREENPLUM__',`,prefunc=MADLIB_SCHEMA.bitmap_agg_pfunc')
);


CREATE AGGREGATE MADLIB_SCHEMA.bitmap_agg
(
    INT8
)
(
    SFUNC=MADLIB_SCHEMA.bitmap_agg_sfunc,
    STYPE=MADLIB_SCHEMA.bitmap
    m4_ifdef(`__GREENPLUM__',`,prefunc=MADLIB_SCHEMA.bitmap_agg_pfunc')
);


/*
 * @brief The implementation of AND operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] AND args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_and
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of OR operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] OR args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_or
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief get the positions of the non-zero bits
 *
 * @param args[0]   the bitmap array
 *
 * @return the array contains the positions of the non-zero bits.
 * @note the position starts from 1.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_nonzero_positions
(
    MADLIB_SCHEMA.bitmap
)
RETURNS INT8[]
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the number of bits whose value is 1.
 *
 * @param args[0]   the bitmap array
 *
 * @return the count of non-zero bits in the bitmap.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_nonzero_count
(
    MADLIB_SCHEMA.bitmap
)
RETURNS INT8
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief get the array representation for the bitmap
 *
 * @param args[0]   the bitmap
 *
 * @return the array representation for the bitmap.
 * @note the first element is the array size
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_return_array
(
    MADLIB_SCHEMA.bitmap
)
RETURNS INT4[]
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the varbit representation for the bitmap
 *
 * @param args[0]   the bitmap
 *
 * @return the varbit representation for the bitmap.
 * @note we should read the bits from left to right
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_return_varbit
(
    MADLIB_SCHEMA.bitmap
)
RETURNS VARBIT
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the bitmap representation for the array
 *
 * @param args[0]   the input array
 *
 * @return the bitmap representation for the array.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.int8array_return_bitmap
(
    INT8[]
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the bitmap representation for the array
 *
 * @param args[0]   the input array
 *
 * @return the bitmap representation for the array.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.int4array_return_bitmap
(
    INT4[]
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;

/*
 * @brief The implementation of = operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] = args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_eq
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of <> operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] <> args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_neq
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of > operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] > args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_gt
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of < operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] < args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_lt
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of >= operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] >= args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_ge
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of <= operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] <= args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_le
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief compare two bitmaps
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return 0 for equality; 1 for greater than; and -1 for less than.
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_cmp
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS INT
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;

/* 
 * Don't comment out commutator and negator for them, or
 * the order by DESC will not work
 */
CREATE OPERATOR MADLIB_SCHEMA.< (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_lt,
    --commutator = operator(MADLIB_SCHEMA.>) ,
    --negator = operator(MADLIB_SCHEMA.>=) ,
    restrict = scalarltsel, join = scalarltjoinsel
);

CREATE OPERATOR MADLIB_SCHEMA.<= (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_le,
    --commutator = operator(MADLIB_SCHEMA.>=) ,
    --negator = operator(MADLIB_SCHEMA.>) ,
    restrict = scalarltsel, join = scalarltjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.> (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_gt,
    --commutator = operator(MADLIB_SCHEMA.<) ,
    --negator = operator(MADLIB_SCHEMA.<=) ,
    restrict = scalargtsel, join = scalargtjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.>= (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_ge,
    --commutator = operator(MADLIB_SCHEMA.<=) ,
    --negator = operator(MADLIB_SCHEMA.<) ,
    restrict = scalargtsel, join = scalargtjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.<> (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_neq,
    --commutator = operator(MADLIB_SCHEMA.<>) ,
    --negator = operator(MADLIB_SCHEMA.=) ,
    restrict = eqsel, join = eqjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.= (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_eq,
    commutator = operator(MADLIB_SCHEMA.=) ,
    negator = operator(MADLIB_SCHEMA.<>) ,
    restrict = eqsel, join = eqjoinsel,
    HASHS,
    MERGES,
    SORT1 = operator(MADLIB_SCHEMA.<),
    SORT2 = operator(MADLIB_SCHEMA.<),
    LTCMP = operator(MADLIB_SCHEMA.<),
    GTCMP = operator(MADLIB_SCHEMA.>)
);


/*
 * define the btree index, so that we can use the type
 * in GROUP BY clause
 */
CREATE OPERATOR CLASS MADLIB_SCHEMA.bitmap_index_btree
DEFAULT FOR TYPE MADLIB_SCHEMA.bitmap USING btree AS
OPERATOR        1       MADLIB_SCHEMA.< ,
OPERATOR        2       MADLIB_SCHEMA.<= ,
OPERATOR        3       MADLIB_SCHEMA.=,
OPERATOR        4       MADLIB_SCHEMA.>= ,
OPERATOR        5       MADLIB_SCHEMA.>,
FUNCTION        1       MADLIB_SCHEMA.bitmap_cmp(MADLIB_SCHEMA.bitmap, MADLIB_SCHEMA.bitmap);


CREATE OPERATOR MADLIB_SCHEMA.| (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap, 
    procedure = MADLIB_SCHEMA.bitmap_or
);

CREATE OPERATOR MADLIB_SCHEMA.& (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap, 
    procedure = MADLIB_SCHEMA.bitmap_and
);


/*
 * CASTs
 */
CREATE CAST (MADLIB_SCHEMA.bitmap AS INT4[]) 
WITH FUNCTION MADLIB_SCHEMA.bitmap_return_array(MADLIB_SCHEMA.bitmap);

CREATE CAST (INT8[] AS MADLIB_SCHEMA.bitmap) 
WITH FUNCTION MADLIB_SCHEMA.int8array_return_bitmap(INT8[]);

CREATE CAST (INT4[] AS MADLIB_SCHEMA.bitmap) 
WITH FUNCTION MADLIB_SCHEMA.int4array_return_bitmap(INT4[]);

CREATE CAST (MADLIB_SCHEMA.bitmap AS VARBIT) 
WITH FUNCTION MADLIB_SCHEMA.bitmap_return_varbit(MADLIB_SCHEMA.bitmap);