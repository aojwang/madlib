/* ----------------------------------------------------------------------- *//** 
 *
 * @file bitmap.sql_in
 *
 * @brief SQL type definitions and functions for bitmap data type
 *        <tt>bitmap</tt>
 *
 * @sa For an introduction to the bitmap implementation, see the module
 *     description \ref grp_bitmap.
 *
 *//* ----------------------------------------------------------------------- */


/**
@addtogroup grp_bitmap

@about

This module implements a user defined type, named MADLIB_SCHEMA.bitmap,  
which gives compressed storage for input numbers and better time performance
for the bitwise operations on bitmap. 

There are lots of data mining algorithms use the bitmap to represent the input
training data, and later do some bitwise operations on the bitmap. For example,
in Apriori, we represent the transaction IDs for each item as a bitmap. If 
we want to get the common transaction IDs for two items, then a simple "and"
operation can achieve the goal. Even more, we can use the bitmap to represent 
the itemsets in each iteration. That is, we can retrieve the itemsets in the
next iteration using "or" operation on every two itemsets in the current iteration.

Let's use an example to explain how we build the bitmap.

\code
'{1,2,3, 32~3100000, 10000000}'::BIGINT[].
\endcode

This array would occupy slightly more than 24MB of memory/disk, most of 
it are continuous numbers. Even if use a bit to represent it, we would still
need more than 9MB space for that. Furthermore, it's hard and inefficient to 
get the common elements for two such arrays.

To solve the problem, we use a novel representation, MADLIB_SCHEMA.bitmap, 
for a numerous of input data. the underlying implementation for the bitmap is 
an INT4 array. Each element in the array is called as a word, which is 4 bytes. 
There are two types of word: normal word and composite word. If the highest bit 
of a word is 0, the it's a normal word. Otherwise, it's a composite word. 
For a normal word, it has 31 bits except for the highest bit. We use the 
position, starts from 1, of the bit in the word to represent a unique input data. 
Therefore, a normal word can represent 31 unique input data. Say, a normal 
word 7, which means the input number is 1,2,3. A composite word can represent 
continuous 0s or 1s. If the second highest bit of the word is 1, then it 
represents continuous 1s, while 0 is for the continuous 0s. The remainder bits 
represent the number of 1s/0s. For example, the above array can be represented
as follows (we use the hexadecimal to represent each element):

\code
array[0x5, 0x7,0xc001869f,0x80036574, 0x80000]
\endcode

    The first element indicates the number of elements in the array. 
    The second word is a normal word. As the first, second and third bit 
    positions of the word are 1, it represents the input numbers (1,2,3).
    The third word is a composite word with continuous 1s. The first bit position
    is 32 (since the first word is a normal word), and the last position is
    31 + x'1869f'::INT * 31 = 3100000. All the bits from 32 to 3100000 is 1, 
    which represents the input numbers (31~310000). The Fourth word is composite
    word with continuous 0s. The first bit position is 3100001, and the last 
    position is 3100000 +  x'36574'::INT * 31 = 9999980. All bits from 3100001
    to 9999980 are 0. The last word is a normal word, the 20th bit position is 1.
    That's means the position from  9999980 to 9999999 is zero, and the bit 
    position 10000000 is 1 (which represent the input number 10000000). 
    Therefore, we only need 16 bytes to represent so many input numbers. 
    
    The module provides the bitmap as a user defined type (MADLIB_SCHEMA.bitmap). 

@usage

    A bitmap can be constructed as follows:
    <pre>
    SELECT 'x1,x2 ,x3 , ..., xk'::MADLIB_SCHEMA.bitmap;
    </pre>
    
    Or, it can also be casted from a integer array:
    <pre>
    SELECT ('{x1, x2, x3, ...xk}'::INT[])::MADLIB_SCHEMA.bitmap;
    </pre>
    
    Or, it can be aggregated from a column with integer type:
    <pre>
    SELECT MADLIB_SCHEMA.bitmap_agg(tid) FROM trans_table;
    </pre>
    where tid is the column with integer type.
    
    Syntax reference can be found in bitmap.sql_in.

    Users need to add MADLIB_SCHEMA to their search_path to use the bitmap 
    operators defined in the module.

@examp

Here, we will give examples for the functions we provided in this version.

The following three examples show how to build a bitmap:

Cast a cstring to a bitmap:
\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap AS bitmap
 bitmap  
---------
 1~3
\endcode

Cast an integer array to a bitmap. NULLs are not allowed. The duplicated 
numbers in the array will be ignored.
\code
sql> SELECT array[1,2,3]::MADLIB_SCHEMA.bitmap AS bitmap
 bitmap  
---------
 1~3
\endcode

Aggregate integers from a table to a bitmap. NULLs and duplicated numbers in 
the aggregate array will be ignored.
\code
sql> CREATE TEMP TABLE t1(id) AS SELECT generate_series(32, 62) UNION ALL
                                 SELECT unnest(array[1,2,3,4];
sql> SELECT MADLIB_SCHEMA.bitmap_agg(id) AS bitmap FROM t1;
 bitmap  
---------
 1~4,32~62
\endcode

The following two examples show how we use the bitwise operations: | and &.
\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap | '4,3,2'::MADLIB_SCHEMA.bitmap AS bitmap_or
 bitmap_or  
---------
 1~4
\endcode

\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap & '4,3,2'::MADLIB_SCHEMA.bitmap AS bitmap_and
 bitmap_and  
---------
 2,3
\endcode


The following two examples show the CASTs for the bitmap:
\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap::INT[] AS intcast
 intcast
---------
 {7}
\endcode

\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap::varbit AS varbitcast
            varbitcast             
-----------------------------------
 111000000000000000000000000000001
\endcode


@sa File bitmap.sql_in documenting the SQL functions.

*/


m4_include(`SQLCommon.m4')

CREATE TYPE MADLIB_SCHEMA.bitmap;

/*
 * @brief the 'in' function for the bitmap data type
 *
 * @param args[0]   the input string, which must be split by a comma.
 *
 * @return the bitmap representing the input string
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_in(cstring)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;


/*
 * @brief the 'out' function for the bitmap data type.
 *
 * @param args[0]   the bitmap
 *
 * @return the string representing the bitmap.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_out(MADLIB_SCHEMA.bitmap)
RETURNS cstring
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;


CREATE TYPE MADLIB_SCHEMA.bitmap (
   internallength = VARIABLE, 
   input = MADLIB_SCHEMA.bitmap_in,
   output = MADLIB_SCHEMA.bitmap_out,
   storage = EXTENDED,
   alignment = int4
);


/*
 * @brief the step function for aggregating the input numbers to
 *        a compressed bitmap.
 *
 * @param args[0]   the array indicating the state
 * @param args[1]   the input number
 * @param args[2]   the number of empty elements will be dynamically
 *                  added to the state array. The default values is 16.
 *
 * @return an array indicating the state after inserting the input number.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_agg_sfunc
(
    MADLIB_SCHEMA.bitmap,
    INT8,
    INT4
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE;


/*
 * @brief the step function for aggregating the input numbers to
 * a compressed bitmap.
 *
 * @param args[0]   The array indicating the state
 * @param args[1]   the input number
 *
 * @return an array indicating the state after inserting the input number.
 * @note the default value for the second parameter is 16
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_agg_sfunc
(
    MADLIB_SCHEMA.bitmap,
    INT8
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE;


/*
 * @brief the pre-function for the bitmap aggregation.
 *
 * @param args[0]   the first state
 * @param args[1]   the second state
 *
 * @return an array of merging the first state and the second state.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_agg_pfunc
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE;


CREATE AGGREGATE MADLIB_SCHEMA.bitmap_agg
(
    INT8,
    INT4
)
(
    SFUNC=MADLIB_SCHEMA.bitmap_agg_sfunc,
    STYPE=MADLIB_SCHEMA.bitmap
    m4_ifdef(`__GREENPLUM__',`,prefunc=MADLIB_SCHEMA.bitmap_agg_pfunc')
);


CREATE AGGREGATE MADLIB_SCHEMA.bitmap_agg
(
    INT8
)
(
    SFUNC=MADLIB_SCHEMA.bitmap_agg_sfunc,
    STYPE=MADLIB_SCHEMA.bitmap
    m4_ifdef(`__GREENPLUM__',`,prefunc=MADLIB_SCHEMA.bitmap_agg_pfunc')
);


/*
 * @brief The implementation of AND operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] AND args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_and
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of OR operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] OR args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_or
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief get the positions of the non-zero bits
 *
 * @param args[0]   the bitmap array
 *
 * @return the array contains the positions of the non-zero bits.
 * @note the position starts from 1.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_nonzero_positions
(
    MADLIB_SCHEMA.bitmap
)
RETURNS INT8[]
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the number of bits whose value is 1.
 *
 * @param args[0]   the bitmap array
 *
 * @return the count of non-zero bits in the bitmap.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_nonzero_count
(
    MADLIB_SCHEMA.bitmap
)
RETURNS INT8
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief get the array representation for the bitmap
 *
 * @param args[0]   the bitmap
 *
 * @return the array representation for the bitmap.
 * @note the first element is the array size
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_return_array
(
    MADLIB_SCHEMA.bitmap
)
RETURNS INT4[]
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the varbit representation for the bitmap
 *
 * @param args[0]   the bitmap
 *
 * @return the varbit representation for the bitmap.
 * @note we should read the bits from left to right
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_return_varbit
(
    MADLIB_SCHEMA.bitmap
)
RETURNS VARBIT
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the bitmap representation for the array
 *
 * @param args[0]   the input array
 *
 * @return the bitmap representation for the array.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.int8array_return_bitmap
(
    INT8[]
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the bitmap representation for the array
 *
 * @param args[0]   the input array
 *
 * @return the bitmap representation for the array.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.int4array_return_bitmap
(
    INT4[]
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;

/*
 * @brief The implementation of = operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] = args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_eq
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of <> operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] <> args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_neq
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of > operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] > args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_gt
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of < operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] < args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_lt
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of >= operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] >= args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_ge
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of <= operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] <= args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_le
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief compare two bitmaps
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return 0 for equality; 1 for greater than; and -1 for less than.
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_cmp
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS INT
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;

/* 
 * Don't comment out commutator and negator for them, or
 * the order by DESC will not work
 */
CREATE OPERATOR MADLIB_SCHEMA.< (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_lt,
    --commutator = operator(MADLIB_SCHEMA.>) ,
    --negator = operator(MADLIB_SCHEMA.>=) ,
    restrict = scalarltsel, join = scalarltjoinsel
);

CREATE OPERATOR MADLIB_SCHEMA.<= (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_le,
    --commutator = operator(MADLIB_SCHEMA.>=) ,
    --negator = operator(MADLIB_SCHEMA.>) ,
    restrict = scalarltsel, join = scalarltjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.> (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_gt,
    --commutator = operator(MADLIB_SCHEMA.<) ,
    --negator = operator(MADLIB_SCHEMA.<=) ,
    restrict = scalargtsel, join = scalargtjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.>= (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_ge,
    --commutator = operator(MADLIB_SCHEMA.<=) ,
    --negator = operator(MADLIB_SCHEMA.<) ,
    restrict = scalargtsel, join = scalargtjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.<> (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_neq,
    --commutator = operator(MADLIB_SCHEMA.<>) ,
    --negator = operator(MADLIB_SCHEMA.=) ,
    restrict = eqsel, join = eqjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.= (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_eq,
    commutator = operator(MADLIB_SCHEMA.=) ,
    negator = operator(MADLIB_SCHEMA.<>) ,
    restrict = eqsel, join = eqjoinsel,
    HASHS,
    MERGES,
    SORT1 = operator(MADLIB_SCHEMA.<),
    SORT2 = operator(MADLIB_SCHEMA.<),
    LTCMP = operator(MADLIB_SCHEMA.<),
    GTCMP = operator(MADLIB_SCHEMA.>)
);


/*
 * define the btree index, so that we can use the type
 * in GROUP BY clause
 */
CREATE OPERATOR CLASS MADLIB_SCHEMA.bitmap_index_btree
DEFAULT FOR TYPE MADLIB_SCHEMA.bitmap USING btree AS
OPERATOR        1       MADLIB_SCHEMA.< ,
OPERATOR        2       MADLIB_SCHEMA.<= ,
OPERATOR        3       MADLIB_SCHEMA.=,
OPERATOR        4       MADLIB_SCHEMA.>= ,
OPERATOR        5       MADLIB_SCHEMA.>,
FUNCTION        1       MADLIB_SCHEMA.bitmap_cmp(MADLIB_SCHEMA.bitmap, MADLIB_SCHEMA.bitmap);


CREATE OPERATOR MADLIB_SCHEMA.| (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap, 
    procedure = MADLIB_SCHEMA.bitmap_or
);

CREATE OPERATOR MADLIB_SCHEMA.& (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap, 
    procedure = MADLIB_SCHEMA.bitmap_and
);


/*
 * CASTs
 */
CREATE CAST (MADLIB_SCHEMA.bitmap AS INT4[]) 
WITH FUNCTION MADLIB_SCHEMA.bitmap_return_array(MADLIB_SCHEMA.bitmap);

CREATE CAST (INT8[] AS MADLIB_SCHEMA.bitmap) 
WITH FUNCTION MADLIB_SCHEMA.int8array_return_bitmap(INT8[]);

CREATE CAST (INT4[] AS MADLIB_SCHEMA.bitmap) 
WITH FUNCTION MADLIB_SCHEMA.int4array_return_bitmap(INT4[]);

CREATE CAST (MADLIB_SCHEMA.bitmap AS VARBIT) 
WITH FUNCTION MADLIB_SCHEMA.bitmap_return_varbit(MADLIB_SCHEMA.bitmap);