/* ----------------------------------------------------------------------- *//** 
 *
 * @file bitmap.sql_in
 *
 * @brief SQL type definitions and functions for bitmap data type
 *        <tt>bitmap</tt>
 *
 * @sa For an introduction to the bitmap implementation, see the module
 *     description \ref grp_bitmap.
 *
 *//* ----------------------------------------------------------------------- */


/**
@addtogroup grp_bitmap

@about

Many data mining algorithms need to deal with integer arrays. For example 
Apriori takes as input the IDs of the transactions that contain a specific item. 
Using an array to keep these IDs leads to large storage overhead and low efficiency 
in processing. We will need a more compact and efficient representation of these 
numbers. MADLIB_SCHEMA.bitmap is a UDT that serves this purpose. 

For example, an input array, say I, like this one: 

\code
'{1,2,3, 32~3100000, 10000000}'::BIGINT[].
\endcode

would occupy more than 24MB of memory/disk space. Using a traditional bitmap 
where each bit represents one number, we would still need more than 9MB space for 
this array.

MADLIB_SCHEMA.bitmap uses an INT4 array to keep the bitmap image. Each element 
in the array is called as a word. There are two types of words: a normal word 
and a composite word. The highest bit of a normal word is 0. The rest 31 bits 
are used to represent numbers. The highest bit of a composite word is 1. 

We can reconstruct the original bitmap by scan through the INT4 array. We use 
CUR to denote the value of the current word. 
1. If the highest two bits of CUR is 11, we extract (CUR & (2^30 - 1))*31 number 
   of 1s.
2. If the highest two bits of CUR is 10, we extract (CUR & (2^30 - 1))*31 number
   of 0s.
3. If the highest bit of CUR is 0, we extract a bitmap which is lowest 31 bits
   of CUR. 
   
A typical usage of bitmap is integer set. We also provide utility functions to 
transform between integer set and bitmap. We use integer array to represent integer
set.
[5, 10, 20] 

With this format, the aforementioned array I would be encoded as the following 
array, denoted as E, with only five words, which occupy only 5 * 4 = 20 bytes: 
\code
array[0x5, 0x7, 0xc001869f, 0x80036574, 0x80000]
\endcode

E[0], i.e. 0x5, is always set to the total 
number of normal and composite words, i.e. 4 plus one. 

E[1], i.e. 0x7, is a normal word. Since lowest 3 bits are all ones, we know that 
the input array I has 1,2,3 in it. 

E[2], i.e. 0xc001869f, is a composite word, The highest two bits are 11, which 
means 

The third word is a composite word, whose highest two bits are 11. Therefore 
 with continuous 1s. The first bit position
    The second word: is 32 (since the first word is a normal word), 
    The third word:
     the last position is
    31 + x'1869f'::INT * 31 = 3100000. All the bits from 32 to 3100000 is 1, 
    which represents the input numbers (31~310000). The Fourth word is composite
    word with continuous 0s. The first bit position is 3100001, and the last 
    position is 3100000 +  x'36574'::INT * 31 = 9999980. All bits from 3100001
    to 9999980 are 0. The last word is a normal word, the 20th bit position is 1.
    That's means the position from  9999980 to 9999999 is zero, and the bit 
    position 10000000 is 1 (which represent the input number 10000000). 
    Therefore, we only need 16 bytes to represent so many input numbers. 
    
    The module provides the bitmap as a user defined type (MADLIB_SCHEMA.bitmap). 

@usage

    A bitmap can be constructed as follows:
    <pre>
    SELECT 'x1,x2 ,x3 , ..., xk'::MADLIB_SCHEMA.bitmap;
    </pre>
    
    Or, it can also be casted from a integer array:
    <pre>
    SELECT ('{x1, x2, x3, ...xk}'::INT[])::MADLIB_SCHEMA.bitmap;
    </pre>
    
    Or, it can be aggregated from a column with integer type:
    <pre>
    SELECT MADLIB_SCHEMA.bitmap_agg(tid) FROM trans_table;
    </pre>
    where tid is the column with integer type.
    
    Syntax reference can be found in bitmap.sql_in.

    Users need to add MADLIB_SCHEMA to their search_path to use the bitmap 
    operators defined in the module.

@examp

Here, we will give examples for the functions we provided in this version.

The following three examples show how to build a bitmap:

Cast a cstring to a bitmap:
\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap AS bitmap
 bitmap  
---------
 1~3
\endcode

Cast an integer array to a bitmap. NULLs are not allowed. The duplicated 
numbers in the array will be ignored.
\code
sql> SELECT array[1,2,3]::MADLIB_SCHEMA.bitmap AS bitmap
 bitmap  
---------
 1~3
\endcode

Aggregate integers from a table to a bitmap. NULLs and duplicated numbers in 
the aggregate array will be ignored.
\code
sql> CREATE TEMP TABLE t1(id) AS SELECT generate_series(32, 62) UNION ALL
                                 SELECT unnest(array[1,2,3,4];
sql> SELECT MADLIB_SCHEMA.bitmap_agg(id) AS bitmap FROM t1;
 bitmap  
---------
 1~4,32~62
\endcode

The following two examples show how we use the bitwise operations: | and &.
\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap | '4,3,2'::MADLIB_SCHEMA.bitmap AS bitmap_or
 bitmap_or  
---------
 1~4
\endcode

\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap & '4,3,2'::MADLIB_SCHEMA.bitmap AS bitmap_and
 bitmap_and  
---------
 2,3
\endcode


The following two examples show the CASTs for the bitmap:
\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap::INT[] AS intcast
 intcast
---------
 {7}
\endcode

\code
sql> SELECT '1,2,3'::MADLIB_SCHEMA.bitmap::varbit AS varbitcast
            varbitcast             
-----------------------------------
 111000000000000000000000000000001
\endcode


@sa File bitmap.sql_in documenting the SQL functions.

*/


m4_include(`SQLCommon.m4')

CREATE TYPE MADLIB_SCHEMA.bitmap;

/*
 * @brief the 'in' function for the bitmap data type
 *
 * @param args[0]   the input string, which must be split by a comma.
 *
 * @return the bitmap representing the input string
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_in(cstring)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;


/*
 * @brief the 'out' function for the bitmap data type.
 *
 * @param args[0]   the bitmap
 *
 * @return the string representing the bitmap.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_out(MADLIB_SCHEMA.bitmap)
RETURNS cstring
AS 'MODULE_PATHNAME'
LANGUAGE C IMMUTABLE STRICT;


CREATE TYPE MADLIB_SCHEMA.bitmap (
   internallength = VARIABLE, 
   input = MADLIB_SCHEMA.bitmap_in,
   output = MADLIB_SCHEMA.bitmap_out,
   storage = EXTENDED,
   alignment = int4
);


/*
 * @brief the step function for aggregating the input numbers to
 *        a compressed bitmap.
 *
 * @param args[0]   the array indicating the state
 * @param args[1]   the input number
 * @param args[2]   the number of empty elements will be dynamically
 *                  added to the state array. The default values is 16.
 *
 * @return an array indicating the state after inserting the input number.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_agg_sfunc
(
    MADLIB_SCHEMA.bitmap,
    INT8,
    INT4
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE;


/*
 * @brief the step function for aggregating the input numbers to
 * a compressed bitmap.
 *
 * @param args[0]   The array indicating the state
 * @param args[1]   the input number
 *
 * @return an array indicating the state after inserting the input number.
 * @note the default value for the second parameter is 16
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_agg_sfunc
(
    MADLIB_SCHEMA.bitmap,
    INT8
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE;


/*
 * @brief the pre-function for the bitmap aggregation.
 *
 * @param args[0]   the first state
 * @param args[1]   the second state
 *
 * @return an array of merging the first state and the second state.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_agg_pfunc
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE;


CREATE AGGREGATE MADLIB_SCHEMA.bitmap_agg
(
    INT8,
    INT4
)
(
    SFUNC=MADLIB_SCHEMA.bitmap_agg_sfunc,
    STYPE=MADLIB_SCHEMA.bitmap
    m4_ifdef(`__GREENPLUM__',`,prefunc=MADLIB_SCHEMA.bitmap_agg_pfunc')
);


CREATE AGGREGATE MADLIB_SCHEMA.bitmap_agg
(
    INT8
)
(
    SFUNC=MADLIB_SCHEMA.bitmap_agg_sfunc,
    STYPE=MADLIB_SCHEMA.bitmap
    m4_ifdef(`__GREENPLUM__',`,prefunc=MADLIB_SCHEMA.bitmap_agg_pfunc')
);


/*
 * @brief The implementation of AND operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] AND args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_and
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of OR operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] OR args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_or
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief get the positions of the non-zero bits
 *
 * @param args[0]   the bitmap array
 *
 * @return the array contains the positions of the non-zero bits.
 * @note the position starts from 1.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_nonzero_positions
(
    MADLIB_SCHEMA.bitmap
)
RETURNS INT8[]
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the number of bits whose value is 1.
 *
 * @param args[0]   the bitmap array
 *
 * @return the count of non-zero bits in the bitmap.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_nonzero_count
(
    MADLIB_SCHEMA.bitmap
)
RETURNS INT8
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief get the array representation for the bitmap
 *
 * @param args[0]   the bitmap
 *
 * @return the array representation for the bitmap.
 * @note the first element is the array size
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_return_array
(
    MADLIB_SCHEMA.bitmap
)
RETURNS INT4[]
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the varbit representation for the bitmap
 *
 * @param args[0]   the bitmap
 *
 * @return the varbit representation for the bitmap.
 * @note we should read the bits from left to right
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_return_varbit
(
    MADLIB_SCHEMA.bitmap
)
RETURNS VARBIT
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the bitmap representation for the array
 *
 * @param args[0]   the input array
 *
 * @return the bitmap representation for the array.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.int8array_return_bitmap
(
    INT8[]
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;


/*
 * @brief get the bitmap representation for the array
 *
 * @param args[0]   the input array
 *
 * @return the bitmap representation for the array.
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.int4array_return_bitmap
(
    INT4[]
)
RETURNS MADLIB_SCHEMA.bitmap
AS 'MODULE_PATHNAME'
LANGUAGE C 
IMMUTABLE STRICT;

/*
 * @brief The implementation of = operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] = args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_eq
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of <> operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] <> args[1].
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_neq
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of > operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] > args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_gt
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of < operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] < args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_lt
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of >= operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] >= args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_ge
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief The implementation of <= operation.
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return the result of args[0] <= args[1].
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_le
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS BOOL
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;


/*
 * @brief compare two bitmaps
 *
 * @param args[0]   the first bitmap array
 * @param args[1]   the second bitmap array
 *
 * @return 0 for equality; 1 for greater than; and -1 for less than.
 * @note it doesn't make sense to compare two bitmap. 
 *       However, the btree index need this operation. 
 *       Here, we just simple compare the two bitmap arrays
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.bitmap_cmp
(
    MADLIB_SCHEMA.bitmap,
    MADLIB_SCHEMA.bitmap
)
RETURNS INT
AS 'MODULE_PATHNAME'
LANGUAGE C
IMMUTABLE STRICT;

/* 
 * Don't comment out commutator and negator for them, or
 * the order by DESC will not work
 */
CREATE OPERATOR MADLIB_SCHEMA.< (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_lt,
    --commutator = operator(MADLIB_SCHEMA.>) ,
    --negator = operator(MADLIB_SCHEMA.>=) ,
    restrict = scalarltsel, join = scalarltjoinsel
);

CREATE OPERATOR MADLIB_SCHEMA.<= (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_le,
    --commutator = operator(MADLIB_SCHEMA.>=) ,
    --negator = operator(MADLIB_SCHEMA.>) ,
    restrict = scalarltsel, join = scalarltjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.> (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_gt,
    --commutator = operator(MADLIB_SCHEMA.<) ,
    --negator = operator(MADLIB_SCHEMA.<=) ,
    restrict = scalargtsel, join = scalargtjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.>= (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_ge,
    --commutator = operator(MADLIB_SCHEMA.<=) ,
    --negator = operator(MADLIB_SCHEMA.<) ,
    restrict = scalargtsel, join = scalargtjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.<> (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_neq,
    --commutator = operator(MADLIB_SCHEMA.<>) ,
    --negator = operator(MADLIB_SCHEMA.=) ,
    restrict = eqsel, join = eqjoinsel
);


CREATE OPERATOR MADLIB_SCHEMA.= (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap,
    procedure = MADLIB_SCHEMA.bitmap_eq,
    commutator = operator(MADLIB_SCHEMA.=) ,
    negator = operator(MADLIB_SCHEMA.<>) ,
    restrict = eqsel, join = eqjoinsel,
    HASHS,
    MERGES,
    SORT1 = operator(MADLIB_SCHEMA.<),
    SORT2 = operator(MADLIB_SCHEMA.<),
    LTCMP = operator(MADLIB_SCHEMA.<),
    GTCMP = operator(MADLIB_SCHEMA.>)
);


/*
 * define the btree index, so that we can use the type
 * in GROUP BY clause
 */
CREATE OPERATOR CLASS MADLIB_SCHEMA.bitmap_index_btree
DEFAULT FOR TYPE MADLIB_SCHEMA.bitmap USING btree AS
OPERATOR        1       MADLIB_SCHEMA.< ,
OPERATOR        2       MADLIB_SCHEMA.<= ,
OPERATOR        3       MADLIB_SCHEMA.=,
OPERATOR        4       MADLIB_SCHEMA.>= ,
OPERATOR        5       MADLIB_SCHEMA.>,
FUNCTION        1       MADLIB_SCHEMA.bitmap_cmp(MADLIB_SCHEMA.bitmap, MADLIB_SCHEMA.bitmap);


CREATE OPERATOR MADLIB_SCHEMA.| (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap, 
    procedure = MADLIB_SCHEMA.bitmap_or
);

CREATE OPERATOR MADLIB_SCHEMA.& (
    leftarg = MADLIB_SCHEMA.bitmap, rightarg = MADLIB_SCHEMA.bitmap, 
    procedure = MADLIB_SCHEMA.bitmap_and
);


/*
 * CASTs
 */
CREATE CAST (MADLIB_SCHEMA.bitmap AS INT4[]) 
WITH FUNCTION MADLIB_SCHEMA.bitmap_return_array(MADLIB_SCHEMA.bitmap);

CREATE CAST (INT8[] AS MADLIB_SCHEMA.bitmap) 
WITH FUNCTION MADLIB_SCHEMA.int8array_return_bitmap(INT8[]);

CREATE CAST (INT4[] AS MADLIB_SCHEMA.bitmap) 
WITH FUNCTION MADLIB_SCHEMA.int4array_return_bitmap(INT4[]);

CREATE CAST (MADLIB_SCHEMA.bitmap AS VARBIT) 
WITH FUNCTION MADLIB_SCHEMA.bitmap_return_varbit(MADLIB_SCHEMA.bitmap);